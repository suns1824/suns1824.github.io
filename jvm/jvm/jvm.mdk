#Java内存区域
## 运行时数据区域
### 程序计数器
程序计数器是一块较小的内存空间,它可以看作是**当前线程所执行的字节码的行号指示器**,  
虚拟机的概念模型里,字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.  
为了线程切换后能回到恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,这类内存区域称为"线程私有"的内存.  
> * thread执行java方法 -- 计数器记录正在执行的虚拟机字节码指令的地址
> * native方法   --  计数器值为空  此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域.

### Java虚拟机栈 
也是线程私有的,生命周期和线程相同.它描述的是**Java方法执行的内存模型**:每个方法在执行的时候都会创建一个栈帧用于存储局部变量表,操作数栈,动态链接,
方法出口等信息.  
局部变量表存放各种编译器可知的xx,局部变量表所需的内存空间在编译期间完成分配(两种异常StackOverflowError和OutOfMemoryError)  

### 本地方法栈  
与虚拟机栈类似,但本地方法栈是为虚拟机使用到的native方法服务的.  

### Java堆
对大多数应用来说,Java堆是Java虚拟机所管理的内存中最大的一块.**被所有线程共享**,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,
几乎所有对象实例和数组都在堆上分配.   
Java堆是垃圾收集器管理的主要区域,因此很多时候被称为"GC堆",Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可.  

### 方法区
各线程共享的内存区域,用于存放被虚拟机加载的类信息,常量,静态变量,即时编译后的代码等数据.  也叫永久代.  该区域的回收目标主要为正对常量池的回收和对类型的卸载.

### 运行时常量池  
方法区的一部分,Class文件中除了有类的各种描述信息外,还有一项信息是常量池,用于存放编译器生成的各种字面量和符号引用(一般还有翻译出来的直接引用),这部分内容将在类加载后进入方法区的运行时常量池存放.
相对于Class文件常量池:具备动态性,运行期间能将新的常量放入池中
 
### 直接内存  
堆外内存  NIO

## HotSpot虚拟机对象 
### 对象创建  
new指令--类加载检查(new指令的参数能否再常量池中定位到一个类的的符号引用,并检查这个类是否被加载,解析,初始化)--为新生对象分配内存(指针碰撞和空闲列表法,依据Java堆的内存是否规整)  
划分空间时考虑并发情况: 
> * CAS配上失败重试来保证更新操作的原子性
> * 把内存分配按照线程划分在不同的空间中  

内存分配完后,虚拟机啊需要将分配到的内存空间都初始化为零值,保证了对象的实例字段在Java代码中可以不赋初始值就直接使用. 
然后对对象进行必要的设置(这个对象是哪个类的实例,如何找类的元数据,对象hash,GC分代年龄),这些存在对象的对象头中.
这时候,还会接着执行<init>方法,将对象进行初始化.  

### 对象的内存布局  
分为3个区域: 
> * 对象头
> * 实例数据
> * 对齐填充  

### 对象的访问定位  
Java程序通过栈上的reference数据来操作堆上的具体对象.reference类型规定了一个指向对象的引用.通过这个引用去定位,访问堆中对象的具体位置,两种方式: 
> * 句柄访问  
> * 直接指针访问 

#垃圾收集器和内存分配策略 
## 对象已死吗 
### 引用计数法 
给对象加一个计数器,有地方引用它就加一,引用失效减一.但是很难解决两个对象之间互相循环引用的问题. 
### 可达性分析算法  
GC Roots  当一个对象到GC Roots没有任何引用链相连,XXX.  
GC Roots:
> * 虚拟机栈中引用的对象(栈中的本地变量表)
> * 方法区中类静态属性引用的对象
> * 方法区中常量引用的对象
> * 本地方法栈中JNI引用的对象

**ps:4种引用**
> * 强引用
> * 软引用(在系统将要发生内存溢出异常之前,将会把软引用关联着的对象列入回收范围)
> * 弱引用(只能生存到下一次GC之前)
> * 虚引用(最弱的引用关系,不会对生存时间造成影响,唯一目的就是能在这个对象被收集器回收时收到一个系统通知)

### 对象的死亡
真正被回收需要经过两次标记:第一次,可达性分析时xxx.然后进行一次筛选,筛选条件是这个对象是否重写了finalize方法,如果没有,那么直接回收;如果覆盖了这个方法,
那么就将其放到一个叫F-Queue的队列中,然后由一个虚拟机自动建立的,低优先级的Finalizer线程区执行它(不保证会等待它运行结束,因为有可能一个对象在finaliz()方法中执行缓慢或者死循环).
如果对象在finalize方法中重写与引用链上的任意一个对象建立连接,自救成功,否则加上标记,凉凉.
**ps**:任何一个对象的finalize方法都只会被系统自动调用一次.   

### 回收方法区  
永久代几乎没有垃圾回收,主要回收两部分:废弃常量和无用的类.
无用类:
> * 该类所有的实例都被回收,Java堆中不存在该类的任何实例
> * 加载该类的ClassLoader已经被回收
> * 该类对应的java.lang.Class对象没有任何地方被引用,无法在任何地方通过反射访问该类的方法.  

## 垃圾收集算法
### 标记清除算法  
先标记对象,然后统一回收.缺点:效率和内存碎片
### 复制算法
内存划分为两个,一个使用完,活着的就移过去,然后这一个全部清掉.  缺点很明显,改善:Eden:Survivor:Survivor = 8:1:1
### 标记整理算法
标记完将所有存活的对象都向一端移动,然后直接直接清理掉边界以外的内存
### 分代收集算法
新生代(复制)老年代(标记清除|标记整理)

## HotSpot的算法实现
### 枚举根节点
扫描所有引用  GC停顿  OopMap可以直接得知哪些地方存放着对象引用
### 安全点
只在安全点停顿下来GC   标准是是否具有让程序长时间执行的特征  同时要考虑如何在GC时让所有线程跑到最近的安全点上安顿下来:抢先式和主动式
### 安全区域 
指一段代码片段之中,引用关系不会发生变化(线程处于sleep或blocked状态,此时程序"不执行",而安全点是针对程序"运行时").

## 内存分配策略  
> * 对象优先在Eden分配,Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC.
> * 大对象直接进入老年代
> * 长期存活的对象进入老年代,虚拟机给每个对象定义了一个对象年龄计数器,对象在Eden出生,经过第一次Minor GC后仍然存活,并被Survivor区容纳,
对象年龄设为,在Survivor区每熬过一次Minor GC,年龄就+1.达到一定程度就进入老年代(也有动态对象年龄判定: Survivor空间中相同年龄所有对象大小的总和
大于Survivor空间的一半,>=该年龄的对象就直接进入xxx).
> * 空间分配担保 --Minor GC之前,虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间,不止于此,还有是否允许冒险xxx.  

[思考:为什么需要由survivor区以及为什么要有两个](https://blog.csdn.net/antony9118/article/details/51425581)