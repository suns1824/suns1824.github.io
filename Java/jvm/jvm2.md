
# Java内存区域
## 运行时数据区域
### 程序计数器
程序计数器是一块较小的内存空间,它可以看作是**当前线程所执行的字节码的行号指示器**,  
虚拟机的概念模型里,字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.  
为了线程切换后能回到恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,这类内存区域称为"线程私有"的内存.  
> * thread执行java方法 -- 计数器记录正在执行的虚拟机字节码指令的地址
> * native方法   --  计数器值为空  此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域.

### Java虚拟机栈 
也是线程私有的,生命周期和线程相同.它描述的是**Java方法执行的内存模型**:每个方法在执行的时候都会创建一个栈帧用于存储局部变量表,操作数栈,动态链接,
方法出口等信息.  
局部变量表存放各种编译器可知的xx,局部变量表所需的内存空间在编译期间完成分配(两种异常StackOverflowError和OutOfMemoryError)  

### 本地方法栈  
与虚拟机栈类似,但本地方法栈是为虚拟机使用到的native方法服务的.  

### Java堆
对大多数应用来说,Java堆是Java虚拟机所管理的内存中最大的一块.**被所有线程共享**,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,
几乎所有对象实例和数组都在堆上分配.   
Java堆是垃圾收集器管理的主要区域,因此很多时候被称为"GC堆",Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可.  

### 方法区
各线程共享的内存区域,用于存放被虚拟机加载的类信息,常量,静态变量,即时编译后的代码等数据.  也叫永久代.  该区域的回收目标主要为针对常量池的回收和对类型的卸载.

### 运行时常量池  
方法区的一部分,Class文件中除了有类的各种描述信息外,还有一项信息是常量池,用于存放编译器生成的各种字面量和符号引用(一般还有翻译出来的直接引用),这部分内容将在类加载后进入方法区的运行时常量池存放.
相对于Class文件常量池:具备动态性,运行期间能将新的常量放入池中
 
### 直接内存  
堆外内存  NIO

## HotSpot虚拟机对象 
### 对象创建  
new指令--类加载检查(new指令的参数能否在常量池中定位到一个类的的符号引用,并检查这个类是否被加载,解析,初始化)--为新生对象分配内存(指针碰撞和空闲列表法,依据Java堆的内存是否规整)  
划分空间时考虑并发情况: 
> * CAS配上失败重试来保证更新操作的原子性
> * 把内存分配按照线程划分在不同的空间中  

内存分配完后,虚拟机需要将分配到的内存空间都初始化为零值,保证了对象的实例字段在Java代码中可以不赋初始值就直接使用. 
然后对对象进行必要的设置(这个对象是哪个类的实例,如何找类的元数据,对象hash,GC分代年龄),这些存在对象的对象头中.
这时候,还会接着执行<init>方法,将对象进行初始化.  

### 对象的内存布局  
分为3个区域: 
> * 对象头
> * 实例数据
> * 对齐填充  

### 对象的访问定位  
Java程序通过栈上的reference数据来操作堆上的具体对象.reference类型规定了一个指向对象的引用.通过这个引用去定位,访问堆中对象的具体位置,两种方式: 
> * 句柄访问                                                    
> * 直接指针访问 

#垃圾收集器和内存分配策略 
## 对象已死吗 
### 引用计数法 
给对象加一个计数器,有地方引用它就加一,引用失效减一.但是很难解决两个对象之间互相循环引用的问题. 
### 可达性分析算法  
GC Roots  当一个对象到GC Roots没有任何引用链相连,XXX.  
GC Roots:
> * 虚拟机栈中引用的对象(栈中的本地变量表)
> * 方法区中类静态属性引用的对象
> * 方法区中常量引用的对象
> * 本地方法栈中JNI引用的对象

**ps:4种引用**
> * 强引用
> * 软引用(在系统将要发生内存溢出异常之前,将会把软引用关联着的对象列入回收范围)
> * 弱引用(只能生存到下一次GC之前)
> * 虚引用(最弱的引用关系,不会对生存时间造成影响,唯一目的就是能在这个对象被收集器回收时收到一个系统通知)

### 对象的死亡
真正被回收需要经过两次标记:第一次,可达性分析时xxx.然后进行一次筛选,筛选条件是这个对象是否重写了finalize方法,如果没有,那么直接回收;如果覆盖了这个方法,
那么就将其放到一个叫F-Queue的队列中,然后由一个虚拟机自动建立的,低优先级的Finalizer线程去执行它(不保证会等待它运行结束,因为有可能一个对象在finaliz()方法中执行缓慢或者死循环).
如果对象在finalize方法中重写与引用链上的任意一个对象建立连接,自救成功,否则加上标记,凉凉.
**ps**:任何一个对象的finalize方法都只会被系统自动调用一次.   

### 回收方法区  
永久代几乎没有垃圾回收,主要回收两部分:废弃常量和无用的类.
无用类:
> * 该类所有的实例都被回收,Java堆中不存在该类的任何实例
> * 加载该类的ClassLoader已经被回收
> * 该类对应的java.lang.Class对象没有任何地方被引用,无法在任何地方通过反射访问该类的方法.  

## 垃圾收集算法
### 标记清除算法  
先标记对象,然后统一回收.缺点:效率和内存碎片
### 复制算法
内存划分为两个,一个使用完,活着的就移过去,然后这一个全部清掉.  缺点很明显,改善:Eden:Survivor:Survivor = 8:1:1
### 标记整理算法
标记完将所有存活的对象都向一端移动,然后直接清理掉边界以外的内存
### 分代收集算法
新生代(复制)老年代(标记清除|标记整理)

## HotSpot的算法实现
### 枚举根节点
扫描所有引用  GC停顿  OopMap可以直接得知哪些地方存放着对象引用
### 安全点
只在安全点停顿下来GC   标准是是否具有让程序长时间执行的特征  同时要考虑如何在GC时让所有线程跑到最近的安全点上安顿下来:抢先式和主动式
### 安全区域 
指一段代码片段之中,引用关系不会发生变化(线程处于sleep或blocked状态,此时程序"不执行",而安全点是针对程序"运行时").

## 内存分配策略  
> * 对象优先在Eden分配,Eden区没有足够空间进行分配时,虚拟机将发起一次Minor GC.
> * 大对象直接进入老年代
> * 长期存活的对象进入老年代,虚拟机给每个对象定义了一个对象年龄计数器,对象在Eden出生,经过第一次Minor GC后仍然存活,并被Survivor区容纳,在Survivor区每熬过一次Minor GC,年龄就+1.达到一定程度就进入老年代(也有动态对象年龄判定: Survivor空间中相同年龄所有对象大小的总和
大于Survivor空间的一半,>=该年龄的对象就直接进入xxx).
> * 空间分配担保 --Minor GC之前,虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间,不止于此,还有是否允许冒险xxx.  

[思考:为什么需要有survivor区以及为什么要有两个](https://blog.csdn.net/antony9118/article/details/51425581)

## 垃圾收集器
[跳转至](gc.md)

# 类文件结构
口号:一次编写,到处运行  
虚拟机--Class文件--代码  

## Class文件的结构  
任何一个Class文件对应唯一一个类或接口的定义信息,但类或接口并不一定都得定义在文件里,也可以通过类加载器直接生成.  
Class文件是一组以字节为基础单位的二进制流.   
两个概念: 无符号数和表.以这两种数据类型为基础进行解析:  
### 魔数和版本号
### 常量池  
常量池主要存放两大类常量:
> * 字面量:Java语言层面的常量
> * 符号引用,包括三大类:类和接口的全限定名;字段的名称和描述符;方法的名称和描述符. 

ps:Java代码在Javac编译时没有连接步骤,而是在虚拟机加载Class文件的时候进行动态连接(也就是虚拟机运行时), 因此Class文件中字段方法的符号引用只有
在经过运行期转换才能得到真正的内存入口地址,才能被虚拟机使用. 
[JVM的符号引用和直接引用](https://www.cnblogs.com/shinubi/articles/6116993.html)  
思考: 为什么Java方法或变量最长为64KB(结合CONSTANT_xxx_info的结构思考)  
常量池中每一项常量都是一个表，在JDK1.7中为了更好地支持动态语言调用，添加了3种新的表结构(结合虚拟机字节码执行引擎部分理解)。   
### 访问标志
类或接口的访问信息
### 类索引,父类索引,接口索引集合
### 字段表集合
### 方法表集合
### 属性表集合

## 字节码指令
1字节数组所表示的操作码,太多了,搜索了解一下

#虚拟机类加载机制
虚拟机把描述类的数据从Class文件(一串二进制字节流)加载到内存,并对数据进行校验,转换解析和初始化，最终形成可以被虚拟机直接使用的Java 类型，这就是虚拟机的类加载机制。
Java语言里，类型的加载连接和初始化过程都是在程序运行时完成的。虽然会带来一定的性能开销,但是会为Java应用程序提供高度的灵活性，Java里天实可以动态扩展的语言特性
就是依赖运行期动态加载和动态连接的特点实现的。例如:编写一个面向接口的应用程序,可以等到运行时在指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个
二进制流作为程序代码的一部分(Applet,JSP,OSGI)。
类的生命周期:从被虚拟机加载到内存开始，到卸载出内存为止。
加载--验证--准备--解析--初始化--使用--卸载  （大致这样，解析也可以在初始化后，为了支持Java运行时绑定）
### 加载 
加载阶段，虚拟机会完成一下三件事：
>* 通过一个类的全限定名来获取这个类的二进制字节流（各种方式）
>* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构（结合上一节Class文件内容和起初方法区介绍）
>* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口  

 **ps**：非数组类的加载阶段可以使用系统提供的引导类加载器完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类
 加载器区控制字节流的获取方式。但是对于数组类(创建一个数组)不是通过类加载器去创建的，是由JVM直接创建的。但是数组类的元素类型最终要靠类加载器去创建。
 
 ### 验证
 这一阶段目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
 ### 准备
 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段
 **ps**： 
 这时候进行内存分配的仅包括类变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。初始值是指零值：
 ```java
   public static int value = 123;
```
在准备阶段后初始值为0，赋值为123的putstatic指令是在程序被编译后，存放在类构造器<clinit>方法中，所以把value赋值为123的操作在初始化阶段才会执行。  
### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
### 初始化 
初始化阶段是执行类构造器<clinit>()方法的过程。
>* <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。编译器收集的顺序是由语句在
源文件中出现的顺序所决定的，xxxxx：
```java
public class Test {
    static {
        i = 0;                      //赋值可以正常编译通过
        System.out.println(i);      //编译器会提示：非法向前引用  
    }                               //可以赋值，但不能引用                
    static int i = 1;
}
```
>* <clinit>()方法与类的构造函数(实例构造器<init>()方法)不同，它不需要显示地调用父类构造器，虚拟机会保证子类的<clinit>()
方法被调用前，xxxx。
>* <clinit>()方法不是必须的，脑补。
>* 只有当父接口中定义的变量使用时，父接口才会初始化（执行xxx方法）。接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
>* JVM会保证一个类的<clinit>方法在多线程环境中被正确地加锁同步。

## 类加载器
加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”是在JVM外部实现的，实现这个动作的代码模块被称为“类加载器”。
### 类加载器作用
### 双亲委派模型
3种类加载器：
>* 启动类加载器  由C++实现，将<JAVA_HOME>\lib目录下或者被-Xbootclasspath参数所指定的路径上的类库加载到JVM内存中。
>* 扩展类加载器  加载<JAVA_HOME>\lib\ext或者被java.ext.dirs系统变量所指定的路径上的所有类库，开发者可以直接使用扩展类加载器。
>* 应用程序类加载器 负责加载用户类路径上所指定的类库，如果程序中没有自定义过自己的类加载器，默认这个为程序的类加载器。

双亲委派模型：类加载器中的层次关系，类加载器之间的父子关系一般使用组合关系而不是继承的关系来实现。  
工作原理：xxx   
好处：Java类随着它的类加载器一起具备了一种带有优先级的层次关系。

# JVM字节码执行引擎
尽管xxx，但是所有的Java虚拟机执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。
## 运行时栈帧结构
栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧中存储着方法的局部变量表，操作数栈，动态连接，方法返回地址等信息。
**ps**：在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写到了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，
仅仅取决于具体的虚拟机实现。  
在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个当前栈帧关联的方法称为当前方法。   
**线程--栈帧--（局部变量表，操作数栈，动态链接，返回地址。。。）**  

### 局部变量表
用于存放方法参数和方法内部定义的局部变量，以变量槽(slot)为基本单位。一个slot长度32还是64位受处理器虚拟机操作系统影响。  
**思考：slot存储64位的数据类型，采取分割存储法，与long和double的非原子性协定中做法类似。但是，由于局部变量表建立在线程的堆栈中，是线程私有的数据，无论读写两个连续的slot是否为原子操作，都不会引起数据安全问题。**    
虚拟机通过索引定位的方式使用局部变量表，第0位默认用于传递方法所属对象实例的引用。slot是可以重用的，如果当前字节码PC计数器的值以及超过了某个变量的作用域，那么xxx。不过着可能会影响GC。  
**ps**：局部变量和类变量不同，没有准备阶段，所以以下代码编译阶段会报错：
```java
public static void main(String[] args) {
    int a;
    System.out.println(a);
}
```
### 操作数栈 
空间占用思想和局部变量表类似，Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，其中“栈”指的就是操作数栈。
### 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Class文件的常量池中存在大量的符号引用，字节码中的方法调用指令以常量池中指向方法的符号引用作为参数）。
这些符号引用一部分在类加载阶段或者第一次使用的时候转化位直接引用（静态引用），另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。
### 方法返回地址
>* 正常完成出口
>* 异常完成出口

## 方法调用
确定被调用方法的版本(即调用哪一个方法)。  
在程序运行时，进行方法调用是最普遍最频繁的操作，Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用）。
### 解析
在类加载的解析阶段，会将Class文件中一部分的符号引用转化为直接引用，这种解析成立的前提是：方法在程序真正运行之前就有一个可确定的版本，
并且该版本在运行期是不可变的：**静态方法和私有方法**。他们适合在类加载阶段进行解析。  
JVM提供了5条字节码指令：
>* invokestatic
>* invokespecial
>* invokevirtual
>* invokeinterface
>* invokedynamic   

其中，invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一版本，符合这个条件的所有静态方法，私有方法，实例构造器，父类方法4类。   
这些方法被称为非虚方法，其他是虚方法（final方法虽然使用invokevirtual指令调用，但它无法被覆盖，没有其他版本，无需对方法接收者进行多态选择，所以也是非虚方法）。

## 分派
**解析调用一定是一个静态的过程，编译期间完全确定，类装载的解析阶段不会把xxx转换为xxx的过程延迟到运行期间完成**。但是分派调用则可能是静态的也可能是动态的，同时还会分为单分派和多分派。  
分派将会揭示多态性特征的一些最基本体现，比如重载和重写在JVM上是如何实现的：JVM如何确定正确的目标方法。
### 静态分派 
```java
Human man = new Man();
```
把上面代码中的Human称为变量的静态类型或者叫外观类型，后面的Man称为变量的实际类型，最主要区别在于变量本身的静态类型不会改变，在编译期是可知的，而实际类型的结果在运行期才可确定。  
JVM（准确说编译器）在重载时通过参数的静态类型而不是实际类型作为判定依据的，javac编译器在编译阶段会根据参数的静态类型决定使用哪个重载版本。  
**所有依赖静态类型来定位方法指向版本的分派动作称为静态分派，静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。**  
编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是唯一的，往往只能确定一个更加合适的版本（编写sayHello尝试）原因：字面量没有显式的静态类型，它的xxx只能通过
语言上的规则区理解和推断。  
**思考：解析和分派的关系** （他们是不同层次上确定目标方法的过程，比如说：静态方法会在类加载期就就进行解析，而静态方法也是有重载版本的，通过静态分派来完成）   
### 动态分派(重写相关)
```java
public class Test {
    static abstract class Human {
        protected abstract void sayHello();
    }
    static class Man extends Human {
        protected void sayHello(){
            System.out.println("man");
        }
    }
    static class Woman extends Human {
        protected void sayHello(){
            System.out.println("woman");
        }    
    }
    
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
```
javap查看一下字节码  
JVM是如何根据实际类型来分派方法执行版本？---invokevirtual指令的多态查找过程：
>* 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
>* 如果在C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，不通过报错
>* 否则，按照继承关系从下向上一次对C的各个父类进行第2步的搜索和验证过程
>* 如果始终没有找到合适方法，报错  

（简言之：invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上）我们把这种在运行期间根据实际类型确定方法执行版本的分派过程称为动态分派。  
 
### 单分派和多分派
方法的接收者和方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。  
截至1.7(看的书基于1.7)，Java的静态分派属于多分派类型，动态分派属于单分派类型。（结合例子自我分析）  

### 动态分派的实现 
动态分派的方法版本选择过程需要在运行时在类的方法元数据中搜索合适的目标方法，出于性能考虑，大部分实现都不会进行如此频繁的搜索。  
最常见的优化手段：为类在方法去中建立一个虚方法表（对应的，invokeinterface执行时也会用到接口方法表）来代替元数据查找以提高性能。
虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有重写xxx，如果重写了，xxx。方法表一般在类加载的连接阶段进行初始化，准备了
类的变量初始值后，JVM会把该类的方法表也初始化完毕。  

### 动态类型语言支持
#### 什么是动态类型语言
关键特征是它的类型检查的主体过程是在运行时而不是编译期。C++和Java是静态类型语言。   
明确一点：一门语言的哪一种检查行为要在运行期进行，哪一种检查要在编译期进行并没有必然的因果逻辑关系，关键是语言规范中认为规定的：
```java
public static void main(String[] args) {
    int[][] array = new int[1][0][-1];
}
```
这段代码能够正常编译，但运行时会报异常。NegativeArraySizeException是一个运行时异常；与之对应，NoClassDefFoundError属于
连接时异常（连接过程在类加载阶段而不是在编译阶段）。而C语言中出现上面类似的代码就会编译通过不了。   
关于类型检查：
```java
obj.println("hello world");
```
>* Java中：obj的静态类型为java.io.PrintStream，那么变量obj的实际类型就必须是PrintStream的子类才是合法的。否则，即使obj确实属于一个有println(String)方法，但与PrintStream接口没有继承关系的类，代码
依旧不能运行--因为类型检查不合法。
>* 但是在JS中，不管obj具体是何种类型，只要这种类型的定义中确实包含有println(String)方法，那么方法调用成功。  

**原因**：Java在编译期间已经将println(String)方法完整的符号引用（这里是CONSTANT_InterfaceMethodref_info常量,结合常量的内部结构思考）生成出来，作为方法调用指令的
参数存储到了class文件中：
```java
invokevirtual #4: //Method java/io/PrintStream.println:(Ljava/lang/String;)V
```
通过这个符号引用，JVM可以翻译出这个方法的直接引用。但是在ECMAScript等动态类型语言中，变量obj本身没有类型，变量obj的值才具有类型（参考js 中 var obj），编译时最多只能确定方法名称，参数，返回值这些信息
而不会去确定方法所在的具体类型（也就是方法接收者不固定）。   

#### JDK1.7与动态类型
1.7之前的字节码指令集，有四个方法调用指令（invokevirtual，invokespecial，invokestatic，invokeinterface），他们的第一个参数都是被调用方法的符号引用。  
**思考**：符号引用在编译时生成，而动态类型语言只有在运行期才能确定接收者类型。如何才能在JVM上实现动态类型语言呢？  
>* 编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配(实现更复杂，同时性能开销)
>* 性能问题可以使用别的办法解决解决  
>* invokedynamic指令和java.lang.invoke包 

**java.lang.invoke包**的主要目的就是在之前单纯依靠符号引用来确定调用的目标方法这种方式之外，提供了一种新的动态确定目标方法的机制，称为MethodHandle。  
以sort方法为例，C++中使用函数指针实现，但是Java没办法单独把一个函数作为参数进行传递(呃呃，1.8之后可以使用Lambda表达式),所以使用Comparator接口。但是Methodhandle出现后，
Java也可以拥有类似于函数指针或者委托的方法别名的工具了。（不演示例子）通常一个MethodHandle的方法模拟了字节码指令调用，使得它的分派逻辑并非固话在Class文件的字节码上，而是通过一个具体方法来实现。而这个方法
本身的返回值(MethodHandle对象),可以视为对最终调用方法的一个“引用”。    
MethodHandle的使用和Reflection类似，但两者由诸多不同：
>* Reflection是在模拟Java代码层次的方法调用，MethodHandle是在模拟字节码层次的方法调用。
>* Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息多。
>* ......

**invokedynamic指令**
和MethodHandle机制的作用一样：解决原有4条invoke指令方法分派规则固化在虚拟机中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中。  
每一处含有invokedynamic指令的位置都称为“动态调用点”。其第一个参数xxx，包含三个信息：xxx。

## 基于栈的字节码解释执行引擎
概念： 解释执行 编译执行  java的方式
基于栈的指令集合和基于寄存器的指令集   可移植，速度慢些。   

## 延申
概念： Tomcat类加载机制   
[思考](https://blog.csdn.net/byamao1/article/details/62884720)    
概念： OSGI 了解    
概念： 字节码生成技术和Java动态代理   
[Java三种代理模式](https://segmentfault.com/a/1190000009235245)  

# 程序编译与代码优化 
>* 前端编译器（编译器的前端，Javac）   ------.java->.class
>* 后端运行期编译器(JIT编译器，将字节码转变为机器码)
>* AOT编译器(静态体检编译器，直接把.java文件编译成机器码)  

## 早期(编译期)优化
从Javac的代码来看，编译过程大致为：
>* 解析与填充符号表过程（解析分为词法分析和语法分析）
>* 插入式注解处理器的注解处理过程
>* 语义分析与字节码生成过程   

**延申：**: 语法糖:泛型与类型擦除&&自动装箱拆箱与遍历循环（包装类的比较问题）&&条件编译  
 
## 晚期(运行期)优化
JIT：Java程序最初是通过解释器进行解释执行的，JVM发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为"热点代码"。为了提高热点代码的执行效率，在运行时，虚拟机会把这些
代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器就是JIT。

思考：
>* 为什么需要解释器和编译器并存(考虑两者优点)
>* 两个即时编译器
>* 判定热点代码

各种编译优化技术：
>* 方法内联
>* 公共表达式消除
>* 数组边界检查消除
>* 逃逸分析  etc

# 并发
合入Java并发笔记中
